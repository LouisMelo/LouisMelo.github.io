<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="平凡的人生千篇一律，而不凡的人生万里挑一。">
<meta property="og:type" content="website">
<meta property="og:title" content="Louis - 东篱之下">
<meta property="og:url" content="https://louismelo.github.io/index.html">
<meta property="og:site_name" content="Louis - 东篱之下">
<meta property="og:description" content="平凡的人生千篇一律，而不凡的人生万里挑一。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Louis - 东篱之下">
<meta name="twitter:description" content="平凡的人生千篇一律，而不凡的人生万里挑一。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://louismelo.github.io/"/>





  <title>Louis - 东篱之下</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Louis - 东篱之下</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/02/09/React笔记-State-and-Lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/React笔记-State-and-Lifecycle/" itemprop="url">React笔记 - State and Lifecycle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T22:30:42+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a>State and Lifecycle</h1><p>直到现在，我们只学会了一种更新 UI 的方法，调用<code>ReactDOM.render()</code>来改变渲染出的组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  );</div><div class="line">  ReactDOM.render(</div><div class="line">    element,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>在这一节当中，我们将学习如何真正的封装<code>Clock</code>组件，并且让它变得可以重复使用。</p>
<p>我们可以先把 clock 的样子封装一下，先将它的 DOM 结构构造出来：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ReactDOM.render(</div><div class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p>然而，这样的做法遗漏了一个最重要的要求：就是我们需要将<code>Clock</code>设置定时器并更新UI的这些功能都在<code>Clock</code>内部实现，理想状态下，我们只需要写一次<code>Clock</code>组件，它就应该可以在其他地方使用，并且自己更新自己。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了实现它，我们需要给<code>Clock</code>组件添加”state”。</p>
<blockquote>
<p>State is similar to props, but it is private and fully controlled by the component.<br>state 与 props 相似，但是它是组件私有的，并且完全由组件控制。</p>
</blockquote>
<h2 id="之前提到过，class-component比functional-component要多一些特别的功能，state-就是其中之一。"><a href="#之前提到过，class-component比functional-component要多一些特别的功能，state-就是其中之一。" class="headerlink" title="之前提到过，class component比functional component要多一些特别的功能，state 就是其中之一。"></a>之前提到过，<code>class component</code>比<code>functional component</code>要多一些特别的功能，state 就是其中之一。</h2><h2 id="Converting-a-Function-to-Class"><a href="#Converting-a-Function-to-Class" class="headerlink" title="Converting a Function to Class"></a>Converting a Function to Class</h2><p>通过以下5个步骤，你可以将<code>Clock</code>这样的 function 改写成 class:</p>
<ol>
<li>用同样的名字，创建一个<code>ES6 class</code>，使其继承自<code>React.Component</code></li>
<li>添加一个<code>render()</code>方法</li>
<li>将 function 的主体全部复制到<code>render()</code>方法中</li>
<li>将<code>render()</code>方法中的<code>this.props</code>全部替换成<code>props</code></li>
<li>将之前声明的 function 删掉</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="现在，Clock就从一个-function-变成了一个-class，它也具备了local-state和lifecycle-hooks的额外功能。"><a href="#现在，Clock就从一个-function-变成了一个-class，它也具备了local-state和lifecycle-hooks的额外功能。" class="headerlink" title="现在，Clock就从一个 function 变成了一个 class，它也具备了local state和lifecycle hooks的额外功能。"></a>现在，<code>Clock</code>就从一个 function 变成了一个 class，它也具备了<code>local state</code>和<code>lifecycle hooks</code>的额外功能。</h2><h2 id="Adding-Local-State-to-a-Class"><a href="#Adding-Local-State-to-a-Class" class="headerlink" title="Adding Local State to a Class"></a>Adding Local State to a Class</h2><p>通过以下的三个步骤，我们可以将<code>date</code>从 props 中移动到 state 里：</p>
<ol>
<li><p>将<code>render()</code>方法中的<code>this.props.date</code>替换为<code>this.state.date</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>添加一个<code>class constructor</code>指定初始时的<code>this.state</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里要注意我们是如何把<code>props</code>传递给父级构造函数的：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>class components 必须调用父级构造函数，并且将<code>props</code>作为参数传递给它。</p>
<ol>
<li>去掉<code>Clock</code>元素的<code>date</code>属性<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们等会再加上定时器的相关代码，现在，代码应该像是这样的：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="下面，我们将让Clock元素自己设定一个定时器，并且每秒钟更新一次。"><a href="#下面，我们将让Clock元素自己设定一个定时器，并且每秒钟更新一次。" class="headerlink" title="下面，我们将让Clock元素自己设定一个定时器，并且每秒钟更新一次。"></a>下面，我们将让<code>Clock</code>元素自己设定一个定时器，并且每秒钟更新一次。</h2><h2 id="Adding-Lifecycle-Methods-to-a-Class"><a href="#Adding-Lifecycle-Methods-to-a-Class" class="headerlink" title="Adding Lifecycle Methods to a Class"></a>Adding Lifecycle Methods to a Class</h2><p>在有许多的组件构成的应用中，有一点是很重要的，就是能在组件被销毁时释放它们所占用的资源。我们想要在每次<code>Clock</code>被渲染到DOM的时候，启动一个定时器，这在 React 中被称为”mounting”。同样，在由<code>Clock</code>渲染的DOM被移除时，我们也需要清除掉这个定时器，这在 React 中被称为”unmounting”。<br>在组件的类中，我们可以声明特殊的方法，这些代码会在组件”mount”和”unmount”时被调用。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="comment">// runs after the component output has been rendered to the DOM</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    <span class="comment">// runs after the component has been removed from DOM</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些方法称为”lifecycle hooks”，<code>componentDidMount()</code>方法会在组件被渲染到DOM后执行，在这个方法内设置定时器是很棒的：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.timerID = setInterval(</div><div class="line">      () =&gt; <span class="keyword">this</span>.tick(),</div><div class="line">      <span class="number">1000</span></div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里将<code>setInterval()</code>方法返回的 int 值存储在<code>this.timerID</code>中，方便在后面 unmount 的时候，对其使用<code>clearInterval()</code>方法。</p>
<blockquote>
<p>While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.</p>
<p>If you don’t use something in render(), it shouldn’t be in the state.</p>
</blockquote>
<p>在<code>componentWillUnmount()</code>方法中，销毁掉定时器：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount() &#123;</div><div class="line">  clearInterval(<span class="keyword">this</span>.timerID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，我们要实现<code>tick()</code>方法：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tick() &#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法会调用<code>this.setState()</code>方法，来安排更新组件的state。<br>好，我们现在再来回顾一下刚才发生了什么，以及方法被调用的顺序：</p>
<ol>
<li>当<code>&lt;Clock /&gt;</code>元素被传递给<code>React.render()</code>方法时，React 会调用<code>Clock</code>组件的构造函数，由于<code>Clock</code>需要展示当前的时间，所以在<code>Clock</code>的构造函数中，<code>this.state</code>初始化了一个包含当前时间的对象，然后我们对它进行更新；</li>
<li>React 接着调用<code>Clock</code>组件的<code>render()</code>方法，这使得 React 知道要在屏幕上展示什么东西。接下来 React 会根据<code>Clock</code>的<code>render()</code>方法来更新 DOM；</li>
<li>当<code>Clock</code>的输出被插入到 DOM 中时，React 会调用<code>componentDidMount()</code>方法，在这个方法内部，<code>Clock</code>向浏览器请求设置一个定时器，每秒调用一次组件中的<code>tick()</code>方法；</li>
<li>每隔一秒钟，浏览器就会调用<code>tick()</code>方法，在这个方法内部，<code>Clock</code>组件通过调用包含当前时间对象的<code>setState()</code>方法来对 UI 进行更新。多亏了<code>setState()</code>方法，React 才能知道组件的状态已经改变了，这时会再次调用<code>render()</code>方法，来确定需要在屏幕上展示出什么。这次，<code>render()</code> 方法中的<code>this.state.date</code>已经不同了，所以渲染出的结果将会包含更新过的时间，React 会对 DOM 进行相对应的更新；</li>
<li>如果<code>Clock</code>组件从 DOM 中被移除了，React 会调用<code>componentWillUnmount()</code>方法来将定时器停止。</li>
</ol>
<hr>
<h2 id="正确使用-State"><a href="#正确使用-State" class="headerlink" title="正确使用 State"></a>正确使用 State</h2><p>对于<code>setState()</code>方法，你需要知道以下三件事情：</p>
<h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><p>举个例子，下面的代码不会对组件进行重新渲染：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wrong</span></div><div class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>;</div></pre></td></tr></table></figure>
<p>正确的方法应该是，使用<code>setState()</code>方法对其进行修改：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;);</div></pre></td></tr></table></figure>
<p>唯一能够对<code>this.state</code>进行赋值的地方是构造函数，除此之外，都不可以。</p>
<h3 id="State-的更新有可能是异步的"><a href="#State-的更新有可能是异步的" class="headerlink" title="State 的更新有可能是异步的"></a>State 的更新有可能是异步的</h3><p>出于性能方面的考虑，React 有可能将多个<code>setState()</code>请求整合成单独一次的更新。由于<code>this.props</code>和<code>this.state</code>都可能被异步更新，所以不要依赖它们的值来计算下一个 state。举例来说，下面的代码可能会导致计数器更新失败：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wrong</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>要改正的话，需要用到第二种形式的<code>setState()</code>方法， 这个方法会接收函数作为参数，而不是以对象作为参数。这个<strong>匿名方法</strong>会接收上一个 state 作为第一个参数，将更新进行时的 props 作为第二个参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct</span></div><div class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</div><div class="line">  counter: prevState.counter + props.increment</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>上面使用了<code>arrow function</code>，其实使用常规的函数也是一样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct</span></div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    counter: prevState.counter + props.increment</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="State-Updates-are-Merged"><a href="#State-Updates-are-Merged" class="headerlink" title="State Updates are Merged"></a>State Updates are Merged</h3><p>当你调用<code>setState()</code>方法的时候，React 会将你提供的对象并入（merge into）当前的状态中。举个例子，你的 state 可能会包含多个独立的变量：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">this</span>.state = &#123;</div><div class="line">    posts: [],</div><div class="line">    comments: []</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，你可以分开调用<code>setState()</code>方法对它们单独进行更新：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">  fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      posts: response.posts</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      comments: response.comments</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The merging is shallow，所以<code>this.setState({comments})</code>会保持<code>this.state.posts</code>的完整，并且整个替换掉<code>this.state.comments</code>。</p>
<hr>
<h2 id="The-Data-Flows-Down"><a href="#The-Data-Flows-Down" class="headerlink" title="The Data Flows Down"></a>The Data Flows Down</h2><p>不管是父级组件还是子级组件，都不能知道一个特定的组件到底是有状态的还是无状态的，它们也不应该关心它是定义成一个函数还是一个类。这就是为什么 state 经常被称作是<code>本地的</code>或者是<code>被封装的</code>，除了自己，别的组件是不能对其进行访问的。组件可以选择将自己的 state 作为 props 传递给它的子级组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div></pre></td></tr></table></figure>
<p>对于用户定义的组件，也是可以的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;</div></pre></td></tr></table></figure>
<p><code>FormattedDate</code>组件将会接收到一个包含在其 props 中的<code>date</code>对象，它不知道这个对象是来自<code>Clock</code>的 state，还是<code>Clock</code>的 props，或者是硬编码进去的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这通常被称作“自顶向下的”或“单向的”数据流，任何的 state 都永远是为某些特定的 component 所有的，并且任何的从那个 state 处得到的数据或者 UI 只能影响它们“下面的”组件。</p>
<blockquote>
<p>如果你把一个组件树想象成由 props 构成的瀑布的花，每个组件的 state 就像一个额外的水源，它在某个任意的点上汇入，但是也将“顺流而下”。</p>
</blockquote>
<p>为了展示所有的组件都是真正独立的，我们可以创建一个<code>App</code>组件来渲染3个<code>&lt;Clock /&gt;</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;Clock /&gt;</div><div class="line">      &lt;Clock /&gt;</div><div class="line">      &lt;Clock /&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">ReactDOM.render(</span></div><div class="line"><span class="regexp">  &lt;App /</span>&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这样，每个<code>Clock</code>都会单独地设置自己的定时器并且更新。</p>
<p>在 React apps 中，考虑一个组件是有状态的还是无状态的，涉及到一个实现的细节，即这个组件是否会<code>随着时间而发生变化</code>。你既可以在有状态的组件中使用无状态的组件，也可以在无状态的组件中，使用有状态的组件，这都是可以的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/30/Git-分支管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/Git-分支管理/" itemprop="url">Git-分支管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T20:36:18+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908633976bb65b57548e64bf9be7253aebebd49af000/0" alt="分支管理"><br>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既<code>安全</code>，又<code>不影响别人工作</code>。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><hr>
<p>在每次提交后，Git都把各个版本串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" alt="master"><br>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向m<code>aster</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" alt="dev"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" alt="new dev"><br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" alt="合并"><br>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908867187c83ca970bf0f46efa19badad99c40235000/0" alt="删除"></p>
<p>好了，看懂了这些基本的流程，我们就开始实战吧：</p>
<p>首先，我们创建一个名为<code>dev</code>的分支，并切换到<code>dev</code>分支上去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch <span class="string">'dev'</span></div></pre></td></tr></table></figure></p>
<p>这里的<code>git checkout -b dev</code>命令表示的是“创建dev分支并切换到dev分支”，这其实相当于两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line">$ git checkout dev</div><div class="line">Switched to branch <span class="string">'dev'</span></div></pre></td></tr></table></figure></p>
<p>然后，使用<code>git branch</code>查看分支情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div></pre></td></tr></table></figure></p>
<p>这条命令会返回所有的分支，并且在当前的分支上，会有一颗<code>*</code>号。<br>现在，我们就可以在<code>dev</code>分支上进行正常的提交了，比如我们再在<code>readme.txt</code>文件里加一行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick.</div></pre></td></tr></table></figure></p>
<p>将这个改动提交到版本库中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'add new branch'</span></div><div class="line">[dev d19f6e8] add new branch</div><div class="line"> 1 file changed, 2 insertions(+)</div></pre></td></tr></table></figure></p>
<p>OK，现在假设我们在<code>dev</code>分支上的工作已经完成了， 现在我们回到<code>master</code>分支上来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</div></pre></td></tr></table></figure></p>
<p>切换回<code>master</code>分支后，我们可以看到，原先在<code>dev</code>分支上修改过的<code>readme.txt</code>文件并没有产生变化，还是那四句话：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517318302/Screen_Shot_2018-01-30_at_9.17.54_PM_ib0lf8.png" alt="切换回master"><br>此时的指针状态应该是这样的：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0" alt="当前指针"><br>现在，我们需要把<code>dev</code>的工作成果合并到<code>master</code>分支上，我们需要<code>git merge</code>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge dev</div><div class="line">Updating a81ac4f..d19f6e8</div><div class="line">Fast-forward</div><div class="line"> readme.txt | 2 ++</div><div class="line"> 1 file changed, 2 insertions(+)</div></pre></td></tr></table></figure></p>
<p><code>git merge</code>命令用于将指定的分支（dev）合并到当前分支（master）上来，现在我们再看一下<code>readme.txt</code>文件的内容，发现多了一行内容了，已经和<code>dev</code>分支上一模一样了。<br>注意上面返回的信息中的<code>Fast-forward</code>消息，这意味着这次的合并模式是<code>快进模式</code>，就是将<code>master</code>的指针向前移动到了<code>dev</code>的指针上，这样的合并速度就非常快，当然不是每次都是<code>快进模式</code>的合并，还有其他的合并方式。<br>合并完成后，假设我们也不再需要<code>dev</code>分支了，我们可以执行命令，将其删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d dev</div><div class="line">Deleted branch dev (was d19f6e8).</div></pre></td></tr></table></figure></p>
<p>删除后，我们再查看一下版本库中分支的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure></p>
<p>现在，我们就只剩<code>master</code>这一个分支了。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><hr>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature1</div><div class="line">Switched to a new branch <span class="string">'feature1'</span></div></pre></td></tr></table></figure></p>
<p>修改<code>readme.txt</code>文件的最后一行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick AND simple.</div></pre></td></tr></table></figure></p>
<p>现在，提交这个分支的修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'AND simple'</span></div><div class="line">[feature1 e412abc] AND simple</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>好的，完成了<code>feature1</code>上的修改，我们现在回到<code>master</code>分支上来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div></pre></td></tr></table></figure></p>
<p>我们再次修改一下<code>readme.txt</code>文件，将最后一行改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick &amp; simple.</div></pre></td></tr></table></figure></p>
<p>提交修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'&amp; simple'</span></div><div class="line">[master 54d63e2] &amp; simple</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>现在，我们可以思考一下版本的指针状态，现在<code>mater</code>和<code>feature1</code>分支都有了新的提交，所以，应该是这样的：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt="分支状态"><br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge feature1</div><div class="line">Auto-merging readme.txt</div><div class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</div><div class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</div></pre></td></tr></table></figure></p>
<p>从返回的信息可以看出来，Git告诉我们在合并时，<code>readme.txt</code>文件存在冲突，需要我们解决了冲突之后再提交结果。我们现在用<code>git status</code>看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">You have unmerged paths.</div><div class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</div><div class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</div><div class="line"></div><div class="line">Unmerged paths:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</div><div class="line"></div><div class="line">	both modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>我们现在再看看<code>readme.txt</code>里面的内容：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517321020/Screen_Shot_2018-01-30_at_10.03.16_PM_xv7szx.png" alt="readme.txt"><br>卧槽，居然变成这样了，要怎么办呢？<br>可以看到，Git使用了<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记了不同分支的内容，我们现在将其改成如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick and simple.</div></pre></td></tr></table></figure></p>
<p>再执行提交操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'and simple'</span></div><div class="line">[master f31c8e4] and simple</div></pre></td></tr></table></figure></p>
<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下面的样子了：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt="分支状态"><br>用带参数的<code>git log</code>命令，也可以看到合并的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</div><div class="line">*   f31c8e4 (HEAD -&gt; master) and simple</div><div class="line">|\</div><div class="line">| * e412abc (feature1) AND simple</div><div class="line">* | 54d63e2 &amp; simple</div><div class="line">|/</div><div class="line">* d19f6e8 add new branch</div></pre></td></tr></table></figure></p>
<p>最后，删除<code>feature1</code>分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature1</div><div class="line">Deleted branch feature1 (was e412abc).</div></pre></td></tr></table></figure></p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><hr>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch &apos;dev&apos;</div></pre></td></tr></table></figure></p>
<p>对<code>readme.txt</code>修改后，进行提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'add merge'</span></div><div class="line">[dev 5b54fb4] add merge</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure></p>
<p>然后，我们切回<code>master</code>并且准备合并<code>dev</code>分支，这里要使用<code>--no-ff</code>参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 4 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">$ git merge --no-ff -m <span class="string">'merge with no-ff'</span> dev</div><div class="line">Merge made by the <span class="string">'recursive'</span> strategy.</div><div class="line"> readme.txt | 1 +</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure></p>
<p>再次使用<code>git log</code>命令，查看一下分支的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</div><div class="line">*   097a662 (HEAD -&gt; master) merge with no-ff</div><div class="line">|\</div><div class="line">| * 5b54fb4 (dev) add merge</div><div class="line">|/</div><div class="line">*   f31c8e4 and simple</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到，不使用<code>Fast forward</code>模式的情况下，分支情况是这样的：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="分支情况"></p>
<h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>分支的功能很强大，所以我们要遵循以下的几个原则来进行分支管理：</p>
<ol>
<li><code>master</code>分支应该只用来进行版本的发布，平时不能在上面工作</li>
<li>干活都应该在<code>dev</code>上面，当需要发布稳定版本的时候，将<code>dev</code>合并到<code>master</code>上去</li>
<li>每个开发的小伙伴都应该从<code>dev</code>上分支出自己的版本，然后时不时地与<code>dev</code>进行合并就行了</li>
</ol>
<p>## </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/29/Git-远程仓库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Git-远程仓库/" itemprop="url">Git-远程仓库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T22:11:58+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h1><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第一步：创建SSH Key。打开terminal，创建SSH Key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t -rsa -C <span class="string">"jsyzliuxb0918@gmail.com"</span></div></pre></td></tr></table></figure></p>
<p>这里我会将默认的<code>/Users/louis/.ssh/id_rsa</code>改为<code>/Users/louis/.ssh/github_rsa</code>，这里是不需要设置passphrase的，如果不小心设置了的话，可以运行下面的命令进行更改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -p</div></pre></td></tr></table></figure></p>
<p>这里会一步一步要求你修改你的密码的。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有<code>github_rsa</code>和<code>github_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>github_rsa</code>是私钥，不能泄露出去，<code>github_rsa.pub</code>是公钥，可以放心地告诉任何人。使用下面的命令复制你的公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pbcopy &lt; ~/.ssh/github_rsa.pub</div></pre></td></tr></table></figure></p>
<p>打开Github，点击头像进入Settings，在左侧选择SSH and GPG Keys：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517236361/Screen_Shot_2018-01-29_at_10.28.11_PM_nk5nbs.png" alt="Github"></p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><hr>
<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517312422/Screen_Shot_2018-01-30_at_7.39.10_PM_li1bdg.png" alt="创建新仓库"><br>在Repository name填入<code>Learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517312560/Screen_Shot_2018-01-30_at_7.42.07_PM_pbg5mf.png" alt="新仓库"><br>目前，在GitHub上的这个<code>Learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>Learngit</code>仓库下运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:LouisMelo/Learngit.git</div></pre></td></tr></table></figure></p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。<br>下面，就可以把本地库的所有内容推送到远程库上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div><div class="line">Counting objects: 27, <span class="keyword">done</span>.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (22/22), <span class="keyword">done</span>.</div><div class="line">Writing objects: 100% (27/27), 2.26 KiB | 0 bytes/s, <span class="keyword">done</span>.</div><div class="line">Total 27 (delta 8), reused 0 (delta 0)</div><div class="line">remote: Resolving deltas: 100% (8/8), <span class="keyword">done</span>.</div><div class="line">To github.com:LouisMelo/Learngit.git</div><div class="line"> * [new branch]      master -&gt; master</div><div class="line">Branch master <span class="built_in">set</span> up to track remote branch master from origin.</div></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：<br><img src="http://res.cloudinary.com/louismelo/image/upload/v1517315199/Screen_Shot_2018-01-30_at_8.26.11_PM_u1rcxt.png" alt="远程仓库"><br>好了，从现在开始，如果本地有了新的提交，你就可以通过下面的命令将它推送到Github了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure></p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/29/Git-时光机穿梭/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Git-时光机穿梭/" itemprop="url">Git-时光机穿梭</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T14:50:36+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git-时光机穿梭"><a href="#Git-时光机穿梭" class="headerlink" title="Git 时光机穿梭"></a>Git 时光机穿梭</h1><p>我们已经可以将文件添加到git仓库了，下面我们试着修改这个文本文件，看看会有什么结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software.</div></pre></td></tr></table></figure></p>
<p>修改完成后，保存，然后运行 <code>git status</code> 看看有什么结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>这样，返回的信息就会告诉我们，现在有文件被修改了，但是还没有被提交（changes not staged for commit）。<br>虽然<code>git status</code>可以告诉我们当前仓库的状况，但是并不能清楚的告诉我们修改了哪些地方。这时候，我们就需要用到<code>git diff</code>命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git diff readme.txt</div><div class="line">diff --git a/readme.txt b/readme.txt</div><div class="line">index 23bc09e..9247db6 100644</div><div class="line">--- a/readme.txt</div><div class="line">+++ b/readme.txt</div><div class="line">@@ -1,2 +1,2 @@</div><div class="line">-Git is version control system.</div><div class="line">+Git is a distributed version control system.</div><div class="line"> Git is free software.</div></pre></td></tr></table></figure></p>
<p>现在，我们知道了readme.txt中只修改了一行内容。所以我们就可以安心的提交更改了:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div></pre></td></tr></table></figure></p>
<p>这时候，我们再来看一下git仓库的状态，使用<code>git status</code>命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	modified:   readme.txt</div></pre></td></tr></table></figure></p>
<p>这时，系统告诉我们，将要被提交的修改包含了readme.txt文件。<br>现在我们就提交这次修改，使用<code>git commit</code>命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'add distributed'</span></div><div class="line">[master 3b15474] add distributed</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>提交完成后，我们再使用<code>git status</code>来查看一下仓库的状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure></p>
<p>这时，返回的信息告诉我们，没有需要提交的修改，而且工作目录是干净的。</p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><hr>
<p>现在我们已经学会了如何修改文件并且将修改提交到git仓库了，下面再联系一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div></pre></td></tr></table></figure></p>
<p>然后提交修改:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m <span class="string">'append GPL'</span></div><div class="line">[master 9b51472] append GPL</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>好，现在我们回顾一下我们一共有多少个版本了:<br>版本1: add readme file<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git is a version control system.</div><div class="line">Git is free software.</div></pre></td></tr></table></figure></p>
<p>版本2: add distributed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software.</div></pre></td></tr></table></figure></p>
<p>版本3: append GPL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div></pre></td></tr></table></figure></p>
<p>在git中，我们可以使用<code>git log</code>命令来查看历史记录，它可以告诉我们每次都修改了些什么:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span></div><div class="line">commit 9b5147211afee2c3b233d2f74de5f4cec710977b (HEAD -&gt; master)</div><div class="line">Author: louis &lt;louis@promote.cache-dns.local&gt;</div><div class="line">Date:   Mon Jan 29 16:26:38 2018 +0800</div><div class="line"></div><div class="line">    append GPL</div><div class="line"></div><div class="line">commit 3b1547438f09df37716d770a9919fce34405994f</div><div class="line">Author: louis &lt;louis@promote.cache-dns.local&gt;</div><div class="line">Date:   Mon Jan 29 16:21:32 2018 +0800</div><div class="line"></div><div class="line">    add distributed</div><div class="line"></div><div class="line">commit 7b235af1f06c6952dd4cd41eea8c77bb02be5dce</div><div class="line">Author: louis &lt;louis@promote.cache-dns.local&gt;</div><div class="line">Date:   Mon Jan 29 14:55:59 2018 +0800</div><div class="line"></div><div class="line">    add readme file</div></pre></td></tr></table></figure></p>
<p>如果觉得输出的信息太多了，可以试着使用<code>git log --pretty=online</code>，这样，就能看到最精简的信息了。</p>
<p>这里的<code>commit 7b235af1f06c6952dd4cd41eea8c77bb02be5dce</code>就是版本号了，和SVN不一样，git的版本号不是1，2，3，4这样递增的数字，而是一个SHA1计算出来的非常大的数字，用16进制表示。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3，4作为版本号，那肯定就冲突了。</p>
<p>好了，现在我们知道了这些版本的历史记录之后，就可以启动时光穿梭机了。我们准备把readme.txt回退到上一个版本，即”add distributed”的那个版本，需要怎么做呢？<br>首先，必须知道当前版本是哪个版本，在git中，使用<code>HEAD</code>表示当前的版本，上一个版本就是<code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>，但是如果是上100个版本呢？我们可以写成<code>HEAD~100</code>。<br>现在我们要把当前版本”append GPL”回退到上一个版本”add distributed”，我们需要使用到<code>git reset</code>命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD^</div><div class="line">HEAD is now at 3b15474 add distributed</div></pre></td></tr></table></figure></p>
<p><code>--hard</code>的含义，后续会讲到，先来看看<code>readme.txt</code>是否回到了<code>add distributed</code>版本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software.</div></pre></td></tr></table></figure></p>
<p>可以发现，现在我们确实回到了<code>add distributed</code>那个版本，我们还可以继续回到上一个版本，不过我们先停一下，使用<code>git log</code>查看一下版本记录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span></div><div class="line">commit 3b1547438f09df37716d770a9919fce34405994f (HEAD -&gt; master)</div><div class="line">Author: louis &lt;louis@promote.cache-dns.local&gt;</div><div class="line">Date:   Mon Jan 29 16:21:32 2018 +0800</div><div class="line"></div><div class="line">    add distributed</div><div class="line"></div><div class="line">commit 7b235af1f06c6952dd4cd41eea8c77bb02be5dce</div><div class="line">Author: louis &lt;louis@promote.cache-dns.local&gt;</div><div class="line">Date:   Mon Jan 29 14:55:59 2018 +0800</div><div class="line"></div><div class="line">    add readme file</div></pre></td></tr></table></figure></p>
<p>什么？！我们的<code>append GPL</code>的版本怎么不见了呢？好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？<br>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是9b51472…，于是就可以指定回到未来的某个版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard 9b51472</div><div class="line">HEAD is now at 9b51472 append GPL</div></pre></td></tr></table></figure></p>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div></pre></td></tr></table></figure></p>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把<code>HEAD从</code>指向<code>append GPL</code>:<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" alt="append GPL"><br>改为指向<code>add distributed</code>:<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907594057a873c79f14184b45a1a66b1509f90b7a000/0" alt="add distributed"><br>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的<code>commit id</code>。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div><div class="line">9b51472 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 9b51472</div><div class="line">3b15474 HEAD@&#123;1&#125;: reset: moving to HEAD^</div><div class="line">9b51472 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</div><div class="line">3b15474 HEAD@&#123;3&#125;: commit: add distributed</div><div class="line">7b235af HEAD@&#123;4&#125;: commit (initial): add readme file</div></pre></td></tr></table></figure></p>
<p>从返回的信息可以看出来，<code>append GPL</code>的<code>commit id</code>为<code>9b51472</code>。这样，我们就又可以回到未来啦！</p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><hr>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<p>工作区（Working Directory）<br>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849082162373cc083b22a2049c4a47408722a61a770000/0" alt="工作区"></p>
<p>版本库（Git Repository）<br>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt="版本库"><br>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div></pre></td></tr></table></figure></p>
<p>然后，在工作区新增一个<code>LICENSE</code>文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ touch LICENSE</div><div class="line">$ nano LICENSE</div></pre></td></tr></table></figure></p>
<p>现在，我们用<code>git status</code>查看一下仓库的状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	modified:   readme.txt</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">	LICENSE</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>返回的信息清楚的告诉了我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>是第一次出现，所以状态是<code>Untracked</code>。</p>
<p>现在，使用两次<code>git add</code>，把两个文件都添加后，再使用<code>git status</code>查看一下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	new file:   LICENSE</div><div class="line">	modified:   readme.txt</div></pre></td></tr></table></figure></p>
<p>现在，暂存区的状态就变成这样了:<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907720458e56751df1c474485b697575073c40ae9000/0" alt="暂存区"><br>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"understand how stage works"</span></div><div class="line">[master 2e3b6fb] understand how stage works</div><div class="line"> 2 files changed, 2 insertions(+)</div><div class="line"> create mode 100644 LICENSE</div></pre></td></tr></table></figure></p>
<p>一旦提交成功后，这时你的工作区就是干净的了:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure></p>
<p>现在，版本库就变成了这样:<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849077337835a877df2d26742b88dd7f56a6ace3ecf000/0" alt="版本库"></p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><hr>
<p>现在，我们已经掌握了暂存区的概念。接下来，我们讨论一下，为什么Git比其他版本控制系统设计的优秀，因为Git跟踪并管理的是修改，而非文件。<br>那什么是修改呢？比如你新增了一行，这就是一个修改；删除了一行，也是一个修改；更改了某些字符，也是一个修改；删了一些又加了一些，也是一个修改；甚至创建一个新文件，也算一个修改。<br>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat readme.text</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes.</div></pre></td></tr></table></figure></p>
<p>然后，添加到暂存区:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	modified:   readme.txt</div></pre></td></tr></table></figure></p>
<p>然后，再次修改<code>readme.txt</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt </div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div></pre></td></tr></table></figure></p>
<p>提交:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'git tracks changes'</span></div><div class="line">[master 43daa3e] git tracks changes</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure></p>
<p>提交后，再看看状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>为什么这里第二次的修改没有被提交呢？<br>我们来回顾一下整个操作过程:<br>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code><br>我们前面讲了，Git管理的是修改，当你使用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。<br>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git diff HEAD -- readme.txt</div><div class="line">diff --git a/readme.txt b/readme.txt</div><div class="line">index 76d770f..a9c5755 100644</div><div class="line">--- a/readme.txt</div><div class="line">+++ b/readme.txt</div><div class="line">@@ -1,4 +1,4 @@</div><div class="line"> Git is a distributed version control system.</div><div class="line"> Git is free software distributed under the GPL.</div><div class="line"> Git has a mutable index called stage.</div><div class="line">-Git tracks changes.</div><div class="line">+Git tracks changes of files.</div></pre></td></tr></table></figure></p>
<p>可见，第二次修改确实没有被提交。那怎么才能提交第二次的修改呢？只有继续使用<code>git add</code>将修改提交到暂存区，然后再使用<code>git commit</code>将暂存区的修改提交。现在可以了解到，每一次修改，如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><hr>
<p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div><div class="line">My stupid boss still prefers SVN.</div></pre></td></tr></table></figure></p>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"> On branch master</div><div class="line"> Changes not staged <span class="keyword">for</span> commit:</div><div class="line">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">       modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>从返回的信息可以发现，你可以使用<code>git checkout -- readme.txt</code>来丢弃工作区的修改:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- readme.txt</div></pre></td></tr></table></figure></p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div></pre></td></tr></table></figure></p>
<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat readme.txt</div><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div><div class="line">My stupid boss still prefers SVN.</div><div class="line"></div><div class="line">$ git add readme.txt</div></pre></td></tr></table></figure></p>
<p>这时，使用<code>git status</code>查看一下当前的状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	modified:   readme.txt</div></pre></td></tr></table></figure></p>
<p>Git同样告诉我们，用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD readme.txt</div><div class="line">Unstaged changes after reset:</div><div class="line">M       readme.txt</div></pre></td></tr></table></figure></p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>还记得如何撤销工作区的修改吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- readme.txt</div><div class="line"></div><div class="line">$ git status</div><div class="line"> On branch master</div><div class="line">nothing to commit (working directory clean)</div></pre></td></tr></table></figure></p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><hr>
<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git add test.txt</div><div class="line">$ git commit -m <span class="string">'add test.txt'</span></div><div class="line">[master e432478] add test.txt</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> create mode 100644 test.txt</div></pre></td></tr></table></figure></p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm test.txt</div></pre></td></tr></table></figure></p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">	deleted:    test.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git rm test.txt</div><div class="line">rm <span class="string">'test.txt'</span></div><div class="line">$ git commit -m <span class="string">'remove test.txt'</span></div><div class="line">[master cdaffb3] remove test.txt</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> delete mode 100644 test.txt</div></pre></td></tr></table></figure></p>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- test.txt</div></pre></td></tr></table></figure></p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/23/Git-简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/Git-简介/" itemprop="url">Git-简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T20:50:05+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><hr>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>运行以下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></p>
<h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><ol>
<li>使用Homebrew安装</li>
<li>使用Xcode中的安装Command Line Tools</li>
</ol>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在git-scm网站下载安装git</p>
<p>最后，需要对git进行初始配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"Your name"</span></div><div class="line">git conifg --global user.email <span class="string">"youremail@example.com"</span></div></pre></td></tr></table></figure></p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><hr>
<p>版本库就是仓库，英文是repository。你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>创建一个版本库很简单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir louis-git</div><div class="line">$ <span class="built_in">cd</span> louis-git</div><div class="line">$ <span class="built_in">pwd</span></div><div class="line">/Users/louis/louis-git</div></pre></td></tr></table></figure></p>
<p><code>pwd</code>的作用是显示当前目录。<br>现在我们通过 <code>git init</code> 来初始化这个git仓库:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/louis/louisgit/.git/</div></pre></td></tr></table></figure></p>
<p>这样，我们就已经创建好一个git仓库了，可以从命令行中看出来，这个仓库现在还是 <code>empty</code> 的。下面我们就开始将文件添加到这个 Git repository。</p>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先需要说明的是，所有的版本控制系统，其实都只能跟踪<code>文本文件</code>的改动，比如TXT，网页，程序代码等，Git也是这样的。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>现在我们在learngit目录下，创建一个新的文本文件，就叫做<code>readme.txt</code>，并在其中输入如下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Git is version control system.</div><div class="line">Git is free software.</div><div class="line">``` </div><div class="line">下面我们要将这个文本文件添加到 git 仓库就需要以下两步: </div><div class="line">第一步，使用`git add`命令</div><div class="line">```bash</div><div class="line">$ git add readme.txt</div></pre></td></tr></table></figure></p>
<p>第二步，使用<code>git commit</code>命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'add a readme file'</span></div></pre></td></tr></table></figure></p>
<p>这样，就成功将<code>readme.txt</code>添加到了git仓库里了，可以说非常简单。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/08/录制用户的音频-视频/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/08/录制用户的音频-视频/" itemprop="url">录制用户的音频 & 视频</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T20:25:42+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="录制音频"><a href="#录制音频" class="headerlink" title="录制音频"></a>录制音频</h2><p>许多浏览器现在都能访问用户的音频和视频输入。</p>
<h3 id="简单的版本"><a href="#简单的版本" class="headerlink" title="简单的版本"></a>简单的版本</h3><p>最简易的方式就是让用户自己提供预先录制的文件。其实现步骤是：创建一个简单的文件输入元素，然后添加一个表示我们只接受音频文件的<code>accept</code>过滤器，在理想情况下，我们可以直接从麦克风获取这些文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"audio/*"</span> <span class="attr">captrue</span>=<span class="string">"microphone"</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>此方法在所有平台上都有效</strong>。在桌面平台上，它会提示用户通过文件系统上传文件（忽略microphone的条件）。在iOS上的Safari中，它会打开麦克风应用让您录制音频，然后将其传回网页；在Android上，它允许用户选择合适的应用来录制音频，并将其传回网页。</p>
<p>用户完成录制并返回网站后，您需要以某种方式掌握文件数据。 为 input 元素附加一个<code>onchange</code>事件，然后读取事件对象的files属性，便可快速获得访问权。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"audio/*"</span> <span class="attr">capture</span>=<span class="string">"microphone"</span> <span class="attr">id</span>=<span class="string">"recorder"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">var</span> recorder = <span class="built_in">document</span>.getElementById(<span class="string">'recorder'</span>);</span></div><div class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'player'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  recorder.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> file = e.target.files[<span class="number">0</span>]; </span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">    player.src =  URL.createObjectURL(file);</span></div><div class="line"><span class="undefined">  &#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在获得文件的访问权之后，便可以对其进行任意操作，比如：</p>
<ul>
<li>将其直接附加到一个<code>audio</code>元素，这样就能播放文件了</li>
<li>将其下载至用户设备</li>
<li>通过将其附加到一个XMLHttpRequest，上传至服务器</li>
<li>通过Web Audio API传递文件</li>
</ul>
<p>尽管使用 input 元素方法获得对音频数据访问权的情况普遍存在，却是最没有吸引力的方案。 因为我们真正需要的是获得对麦克风的访问权，直接在页面内提供良好的体验。</p>
<h3 id="以交互方式访问麦克风"><a href="#以交互方式访问麦克风" class="headerlink" title="以交互方式访问麦克风"></a>以交互方式访问麦克风</h3><p>现代浏览器可直连麦克风，我们可以借此打造与网页完全集成的体验，让用户永远都不需要离开浏览器。</p>
<h4 id="获得对麦克风的访问权"><a href="#获得对麦克风的访问权" class="headerlink" title="获得对麦克风的访问权"></a>获得对麦克风的访问权</h4><p>我们可以利用 WebRTC(Web Real-Time Communication) 规范中名为 <code>getUserMedia()</code> 的API直接访问麦克风。<code>getUserMedia()</code> 将提示用户授予对其相连<strong>麦克风(microphone)</strong>和<strong>摄像头(camera)</strong>的访问权。<br>如果授权成功了，该API会返回一个 <code>Stream</code>，其中包含了来自麦克风和摄像头的数据，然后我们将音频数据附加到一个 <code>&lt;audio&gt;</code> 元素、将其附加到一个网络音频 <code>AudioContext</code>或者使用 <code>MediaRecorder</code> API将其进行保存。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'player'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">var</span> handleSuccess = <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>)</span>&#123;</span></div><div class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.URL) &#123;</span></div><div class="line"><span class="javascript">      player.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span></div><div class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></div><div class="line"><span class="undefined">      player.src = stream;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  &#125;;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  navigator.mediaDevices.getUserMedia(&#123;<span class="attr">audio</span>:<span class="literal">true</span>, <span class="attr">video</span>:<span class="literal">false</span>&#125;).then(handleSuccess);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在开启网页后，会询问是否允许访问麦克风设备，并且此时，点击 <code>&lt;audio&gt;</code> 控件的播放按钮，会实时的输出麦克风接收到的音频。<br>不过，这段代码的代码作用并不太大。我们所能做的太少了。</p>
<h4 id="从麦克风获得原始数据"><a href="#从麦克风获得原始数据" class="headerlink" title="从麦克风获得原始数据"></a>从麦克风获得原始数据</h4><h4 id="保存来自麦克风的数据"><a href="#保存来自麦克风的数据" class="headerlink" title="保存来自麦克风的数据"></a>保存来自麦克风的数据</h4><p>想要保存来自麦克风的数据，最简便的方法就是使用 <code>MediaRecorder</code> API。</p>
<p><code>MediaRecorder</code> API 将获取 <code>getUserMedia</code> 创建的卡片流信息，然后渐进式的将卡片信息流中的数据保存到首选目的地。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"download"</span>&gt;</span>Download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"stop"</span>&gt;</span>Stop<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">let</span> shouldStop = <span class="literal">false</span>;</span></div><div class="line"><span class="javascript">  <span class="keyword">let</span> stopped = <span class="literal">false</span>;</span></div><div class="line"><span class="javascript">  <span class="keyword">const</span> downloadLink = <span class="built_in">document</span>.getElementById(<span class="string">'download'</span>);</span></div><div class="line"><span class="javascript">  <span class="keyword">const</span> stopButton = <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  stopButton.addEventListen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">    shouldStop = <span class="literal">true</span>;</span></div><div class="line"><span class="undefined">  &#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">var</span> handleSuccess = <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>)</span>&#123;</span></div><div class="line"><span class="javascript">    <span class="keyword">const</span> options = &#123;<span class="attr">mimeType</span>:<span class="string">'video/webm;codecs=vp9'</span>&#125;;</span></div><div class="line"><span class="javascript">    <span class="keyword">const</span> recordedChunks = [];</span></div><div class="line"><span class="javascript">    <span class="keyword">const</span> mediaRecorder = <span class="keyword">new</span> MediaRecorder(stream, options);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    mediaRecorder.addEventListener(<span class="string">'dataavailable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="keyword">if</span> (e.data.size &gt; <span class="number">0</span>) &#123;</span></div><div class="line"><span class="undefined">        recordedChunks.push(e.data);</span></div><div class="line"><span class="undefined">      &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">      <span class="keyword">if</span>(shouldStop === <span class="literal">true</span> &amp;&amp; stopped === <span class="literal">false</span>) &#123;</span></div><div class="line"><span class="undefined">        mediaRecorder.stop();</span></div><div class="line"><span class="javascript">        stopped = <span class="literal">true</span>;</span></div><div class="line"><span class="undefined">      &#125;</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    mediaRecorder.addEventListener(<span class="string">'stop'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">      downloadLink.href = URL.createObjectURL(<span class="keyword">new</span> Blob(recordedChunks));</span></div><div class="line"><span class="javascript">      downloadLink.download = <span class="string">'acetest.wav'</span>;</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">    mediaRecorder.start();</span></div><div class="line"><span class="undefined">  &#125;;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  navigator.mediaDevices.getUserMedia(&#123;<span class="attr">audio</span>:<span class="literal">true</span>, <span class="attr">video</span>:<span class="literal">false</span>&#125;).then(handleSuccess);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/05/MongoDB-Socket-io-Chat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/05/MongoDB-Socket-io-Chat/" itemprop="url">MongoDB Socket.io Chat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T00:03:31+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MongoDB-Socket-io-搭建聊天室应用"><a href="#MongoDB-Socket-io-搭建聊天室应用" class="headerlink" title="MongoDB + Socket.io 搭建聊天室应用"></a>MongoDB + Socket.io 搭建聊天室应用</h2><p>搞了一天的时间，写个小结稍微总结一下过程中碰到的问题。</p>
<h3 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h3><p>socket.io是聊天室应用的主要通信组件，它使得客户端和服务器可以实时双工的进行基于事件的通信，这是聊天室的基础。在socket.io的官网上，有一个很简单的聊天小应用，主要介绍了在express框架下使用socket.io搭建chat demo的过程。</p>
<p>在服务器端，主要有以下几个方法较为常用: </p>
<ol>
<li><code>io.on(&#39;connection&#39;, (socket) =&gt; {})</code>: 在客户端建立连接的时候会触发这个函数，会通知服务器，有客户端已经连入聊天应用了。</li>
<li><code>io.on(&#39;disconnect&#39;, () =&gt; {})</code>: 在客户端关闭连接的时候会触发这个函数，告知服务器端，有个客户端已经断开连接了。</li>
<li><code>io.emit(&#39;someEvent&#39;, object)</code>: 向所有人发送一个事件，并传递一个对象</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2018/01/02/微信小程序（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/微信小程序（一）/" itemprop="url">微信小程序（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T23:42:33+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h2><h3 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a>JSON配置</h3><p>在自动创建的项目文件中，有4个json文件，我们依次来解释一下它们的功能。</p>
<h4 id="小程序配置-app-json"><a href="#小程序配置-app-json" class="headerlink" title="小程序配置 app.json"></a>小程序配置 app.json</h4><p>app.json是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部tab等。对于自动创建的项目中的app.json文件，包括了pages和window两个字段:</p>
<ol>
<li>pages: 用来描述当前小程序的所有页面路径，为了让微信客户端知道当前你的小程序页面定义在哪个目录。也就是说，这就相当于一个路由配置，目的是为了给微信程序找到正确的页面路径；</li>
<li>window: 小程序所有页面的顶部背景颜色，文字颜色的定义都在这个字段里<br>其他的一些可能用到的app.json配置项为:</li>
<li>tabBar: 设置底部tab的表现（这里底部的tab是用来导航的，而不是我需要的输入控件）</li>
<li>networkTimeout: 设置网络超时时间</li>
<li>debug: 设置是否开启debug模式</li>
</ol>
<h4 id="工具配置-project-config-json"><a href="#工具配置-project-config-json" class="headerlink" title="工具配置 project.config.json"></a>工具配置 project.config.json</h4><p>这个配置文件是为了方便开发者使用的，比如开发者对于开发环境的一些配置，会记录在这个文件中，等到他换其他电脑或者重新安装开发工具的时候，只要载入同一个项目的代码包，那么开发者工具就会帮他恢复之前对于开发环境的个性化配置。</p>
<h4 id="页面配置-page-json"><a href="#页面配置-page-json" class="headerlink" title="页面配置 page.json"></a>页面配置 page.json</h4><p>在页面路径下的page.json主要用来控制与小程序页面相关的配置。app.json是全局配置文件，而page.json是某个页面的配置文件，这让某个单独的页面可以被独立定义。</p>
<h3 id="WXML-模板"><a href="#WXML-模板" class="headerlink" title="WXML 模板"></a>WXML 模板</h3><p>从事过网页编程的人都知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。</p>
<p>同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。在pages/index/index.wxml文件中有如下的代码:</p>
<p>在这个文件中，我们可以看出来，大体的结构与HTML语句是很相似的，但是也有很多不一样的地方:</p>
<ol>
<li>标签名称不一样: 在HTML语言中，通常使用的标签是div, p, span等，而在这里，小程序的WXML使用的是view, button, text这样的标签。这些标签是小程序为开发者包装好的基本能力，把一些常用的组件包装起来，提高开发者的效率。</li>
<li>多了一些<code>wx:if</code>这样的属性以及这样的表达式: 在一般的网页开发中，我们通常使用JS操作DOM，以引起界面的变化来响应用户的操作。微信小程序使用MVVM的开发模式，提倡把渲染和逻辑分开，就是不要再让JS直接操作DOM，而只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。通过的语法把一个变量绑定到界面上，称之为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要if/else, for等控制能力，在小程序里边，这些控制能力都用wx:开头的属性来表达。</li>
</ol>
<h4 id="WXML-详细"><a href="#WXML-详细" class="headerlink" title="WXML 详细"></a>WXML 详细</h4><p>WXML(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件和事件系统，可以构建出页面的结构。其具有以下的多项能力:</p>
<ol>
<li>数据绑定: <code></code></li>
<li>列表渲染: <code>wx:for</code></li>
<li>条件渲染: <code>wx:if</code> &amp; <code>wx:else</code></li>
<li>模板: 可以在模板中定义代码片段，然后在不同地方调用（可以将用户发言的message作为模板，多次调用）</li>
<li>事件: 将组件与事件处理函数进行绑定</li>
</ol>
<h3 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h3><p>WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。</p>
<ol>
<li>小程序提供了专门的尺寸单位rpx: 开发者可以不用操心不同设备像素比的麻烦，底层会进行换算。</li>
<li>提供了全局的样式和局部的样式: 与app.json和page.json的概念相同，可以有app.wxss作为全局样式，也可以有page.wxss对单个页面样式进行修改。</li>
</ol>
<h3 id="JS-交互逻辑"><a href="#JS-交互逻辑" class="headerlink" title="JS 交互逻辑"></a>JS 交互逻辑</h3><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。</p>
<h2 id="小程序的能力"><a href="#小程序的能力" class="headerlink" title="小程序的能力"></a>小程序的能力</h2><h3 id="小程序的启动"><a href="#小程序的启动" class="headerlink" title="小程序的启动"></a>小程序的启动</h3><p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p>
<p>紧接着通过app.json的pages字段就可以知道你当前的小程序的所有页面路径:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"pages"</span>:[</div><div class="line">    <span class="string">"pages/index/index"</span>,</div><div class="line">    <span class="string">"pages/logs/logs"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置说明在自动创建的小程序项目里，定义了两个页面，分别位于pages/index/index以及pages/logs/logs。写在pages字段的第一个页面就是小程序的首页（不论命名如何）。</p>
<p>小程序启动之后，在<code>app.js</code>定义的<code>App</code>实例的<code>onLaunch</code>回调会被执行:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">App(&#123;</div><div class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 小程序启动之后 触发</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>整个小程序只有一个<code>App</code>实例，是全部页面共享的。</p>
<h3 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h3><p>我们可以观察到<code>pages/logs/logs</code>下其实是包括了4种文件的，微信客户端会现根据<code>logs.json</code>配置生产一个界面，顶部的颜色和文字都可以在这个json文件中定义好。紧接着客户端就会装置这个页面的 WXML 结构和 WXSS 样式。最后客户端会装在<code>logs.js</code>，你可以看到<code>logs.js</code>的大体内容就是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  data: &#123; <span class="comment">// 参与页面渲染的数据</span></div><div class="line">    logs: []</div><div class="line">  &#125;,</div><div class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 页面渲染后 执行</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>Page</code>是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会结合<code>data</code>数据和<code>index.wxml</code>一起渲染出最终的结构，于是就看到了你看到的小程序的样子。在渲染完界面之后，页面实例就会收到一个<code>onLoad</code>的回调，你可以在这个回调里处理你的逻辑。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼成自己的小程序。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。</p>
<p>获取地理位置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wx.getLocation(&#123;</div><div class="line">    type: <span class="string">'wgs84'</span>,</div><div class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> latitude = res.latitude</div><div class="line">        <span class="keyword">var</span> longtitude = res.longtitude</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>调用微信扫一扫:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wx.scanCode(&#123;</div><div class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(res)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2017/10/25/IFE前端-Task0001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/IFE前端-Task0001/" itemprop="url">IFE前端 - Task0001</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T20:31:52+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML、CSS基础教程"><a href="#HTML、CSS基础教程" class="headerlink" title="HTML、CSS基础教程"></a>HTML、CSS基础教程</h1><hr>
<h2 id="任务目的"><a href="#任务目的" class="headerlink" title="任务目的"></a>任务目的</h2><hr>
<h2 id="掌握HTML、CSS基础知识、能够熟练运用HTML、CSS编写页面"><a href="#掌握HTML、CSS基础知识、能够熟练运用HTML、CSS编写页面" class="headerlink" title="掌握HTML、CSS基础知识、能够熟练运用HTML、CSS编写页面"></a>掌握HTML、CSS基础知识、能够熟练运用HTML、CSS编写页面</h2><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><hr>
<h2 id="1-建立你的第一个网页"><a href="#1-建立你的第一个网页" class="headerlink" title="1. 建立你的第一个网页"></a>1. 建立你的第一个网页</h2><hr>
<h3 id="1-1-期望达成"><a href="#1-1-期望达成" class="headerlink" title="1.1 期望达成"></a>1.1 期望达成</h3><ul>
<li>了解什么是Web: <strong>Web 2.0是一种新的互联网方式，通过网络应用（Web Applications）促进网络上人与人间的信息交换和协同合作，其模式更加以用户为中心。典型的Web 2.0站点有：网络社区、网络应用程序、社交网站、博客、Wiki等等。</strong></li>
<li>了解什么事HTML: <strong>HTML 是一种标记语言（markup language）。它告诉浏览器如何显示内容。HTML把内容（文字，图片，语言，影片等等）和表现（这个内容是如何显示，比如文字用什么颜色显示等等）分开。HTML使用预先定义的元素集合来识别内容形态。 元素包含一个以上的标记来包含或者表达内容。标记利用尖括号表示，而结束标记（用来指示内容尾端）则在前面加上斜线。</strong></li>
<li>了解一些基本的HTML语句及标签: <strong><head>、</head><body>、<p></p></body></strong>…</li>
<li>能够写出自己的第一个HTML</li>
</ul>
<hr>
<h3 id="1-2-任务描述"><a href="#1-2-任务描述" class="headerlink" title="1.2 任务描述"></a>1.2 任务描述</h3><p>创建一个HTML文件，比如task0001.html文件，在里面实现一些代码，实现你的第一个网页。</p>
<ul>
<li>一个一级标题</li>
<li>一个无序列表</li>
<li>一个二级标题</li>
<li>一个段落</li>
<li>一个图片</li>
</ul>
<hr>
<h3 id="1-3-任务代码"><a href="#1-3-任务代码" class="headerlink" title="1.3 任务代码"></a>1.3 任务代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Louismelo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"task0001.html"</span>&gt;</span>Homepage<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/LouisMelo"</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Louis love snow 4-ever~<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>昔日我如此苍老，现在却风华正茂！————Bob Dylan<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://avatars3.githubusercontent.com/u/18358511?s=460&amp;v=4"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="2-给你的网页加点样式"><a href="#2-给你的网页加点样式" class="headerlink" title="2. 给你的网页加点样式"></a>2. 给你的网页加点样式</h2><hr>
<h3 id="2-1-期望达成"><a href="#2-1-期望达成" class="headerlink" title="2.1 期望达成"></a>2.1 期望达成</h3><ul>
<li>了解什么是CSS: <strong>Cascading Style Sheets是一种用来为结构化文档添加样式的计算机语言</strong></li>
<li>了解HTML与CSS是如何一起工作的: <strong>首先浏览器会将标记语言和CSS转换成DOM，融合相应的文档内容和样式表，然后浏览器把DOM展示出来成为网页</strong><br><img src="http://res.cloudinary.com/louismelo/image/upload/v1508936703/css_rendering.png" alt="How TO Work"></li>
<li>了解基本的CSS语法: <strong>每一条rule由一个selector作为开头，后面跟着花括号，花括号内的每一条语句称为一个declaration，每个declaration由一个property-value pairs构成</strong></li>
<li>尝试使用几个简单的CSS属性</li>
</ul>
<hr>
<h3 id="2-2-任务描述"><a href="#2-2-任务描述" class="headerlink" title="2.2 任务描述"></a>2.2 任务描述</h3><p>学习以下CSS是如何运作的，然后创建一个task0001.css文件，并在task0001.html中引入它。</p>
<ul>
<li>让一级标题的颜色变成蓝色</li>
<li>二级标题的文字大小变成14px</li>
<li>段落的文字大小变成12px，文字颜色是黄色，带一个黑色的背景色</li>
<li>图片有一个红色的，2px粗的边框</li>
</ul>
<hr>
<h3 id="2-3-任务代码"><a href="#2-3-任务代码" class="headerlink" title="2.3 任务代码"></a>2.3 任务代码</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">color</span>: dodgerblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h2</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">    <span class="attribute">color</span>: yellow;</div><div class="line">    <span class="attribute">background-color</span>: black;</div><div class="line">    <span class="attribute">width</span>: <span class="number">465px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">    <span class="attribute">border-style</span>: solid;</div><div class="line">    <span class="attribute">border-width</span>: <span class="number">2px</span>;</div><div class="line">    <span class="attribute">border-color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-稍微放松一下"><a href="#3-稍微放松一下" class="headerlink" title="3. 稍微放松一下"></a>3. 稍微放松一下</h2><hr>
<h3 id="3-1-期望达成"><a href="#3-1-期望达成" class="headerlink" title="3.1 期望达成"></a>3.1 期望达成</h3><ul>
<li>对于HTML及CSS的发展史有一个大概的了解</li>
<li>明白HTML5和之前的版本大概有什么区别</li>
</ul>
<h2 id="4-CSS基础"><a href="#4-CSS基础" class="headerlink" title="4. CSS基础"></a>4. CSS基础</h2><hr>
<h3 id="4-1-期望达成"><a href="#4-1-期望达成" class="headerlink" title="4.1 期望达成"></a>4.1 期望达成</h3><ul>
<li>掌握CSS各种选择器: <strong>simple selectors, attribute selectors, pseudo-classes and pseudo-elements, combinators and multiple selectors</strong></li>
<li>掌握CSS的继承、层叠、样式优先级机制</li>
</ul>
<h2 id="5-让页面样式丰富起来"><a href="#5-让页面样式丰富起来" class="headerlink" title="5. 让页面样式丰富起来"></a>5. 让页面样式丰富起来</h2><hr>
<h3 id="5-1-期望达成"><a href="#5-1-期望达成" class="headerlink" title="5.1 期望达成"></a>5.1 期望达成</h3><ul>
<li>掌握文本、文字、链接相关的样式属性</li>
<li>掌握背景属性</li>
<li>掌握列表相关的样式属性</li>
<li>深入了解行高属性</li>
</ul>
<h3 id="5-2-任务描述"><a href="#5-2-任务描述" class="headerlink" title="5.2 任务描述"></a>5.2 任务描述</h3><p>快速实践以下文本相关的所有属性内容:</p>
<ul>
<li><code>text-indent</code>: <strong>Specify how much horizontal space should be left before the beginning of the first line of the text content.</strong></li>
<li><code>text-transform</code>: <strong>对于英文生效，对于中文不生效，主要是大小，小写，首字母大写以及等宽字体几个option.</strong></li>
<li><code>text-decoration</code>: <strong>Sets/unsets text decorations on fonts (you’ll mainly use this to unset the default underline on links when styling them.)</strong></li>
<li><code>text-align</code>: <strong>The text-align property is used to control how text is aligned within its containing content box.</strong></li>
<li><code>word-spacing</code>: <strong>The letter-spacing and word-spacing properties allow you to set the spacing between letters and words in your text.对于中文而言，每个字之间的间距是由<code>letter-spacing</code>决定的</strong></li>
<li><code>color</code>: <strong>The color property sets the color of the foreground content of the selected elements (which is usually the text, but can also include a couple of other things, such as an underline or overline placed on text using the text-decoration property).</strong></li>
<li><code>white-space</code>: <strong>Define how whitespace and associated line breaks inside the element are handled.</strong></li>
<li><code>font</code>: </li>
<li><code>font-family</code>:</li>
<li><code>font-size</code>:</li>
<li><code>font-weight</code>:</li>
<li><code>font-face</code>: <strong>可以使用自己定义的字体</strong></li>
</ul>
<h2 id="6-盒模型及定位"><a href="#6-盒模型及定位" class="headerlink" title="6. 盒模型及定位"></a>6. 盒模型及定位</h2><hr>
<h3 id="6-1-期望达成"><a href="#6-1-期望达成" class="headerlink" title="6.1 期望达成"></a>6.1 期望达成</h3><ul>
<li>掌握块状元素、内联元素、和内联块元素的概念与区别<ul>
<li>块状（block）元素: <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code> <ol>
<li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</li>
<li>元素的高度、宽度、行高以及顶和底边距都可以设置。</li>
<li>元素宽度在不设定的情况下，是它父容器的100%（和父级元素的宽度一致），除非设定一个宽度。</li>
</ol>
</li>
<li>内联（inline）元素: <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code><ol>
<li>和其他元素都在一行上。</li>
<li>元素的高度、宽度及顶部和底部边距<code>不可</code>设置。</li>
<li>元素的宽度就是它包含的文字或图片的宽度，<code>不可</code>改变.</li>
</ol>
</li>
<li>内联块元素: <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code><ol>
<li>和其他元素都在一行上</li>
<li>元素的高度、宽度、行高以及顶和底边距都可以设置。</li>
</ol>
</li>
</ul>
</li>
<li>掌握盒模型的所有概念，学会如何计算各种盒模型相关的数值: <code>content</code>、<code>padding</code>、<code>margin</code></li>
<li>掌握<code>position</code>的相关知识<ul>
<li>流动模型(flow): 默认的网页布局模式<ol>
<li>块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布</li>
<li>内联元素都会在所处的包含元素内从左到右水平分布显示</li>
</ol>
</li>
<li>浮动模型(float): 让块状元素并排显示</li>
<li>层模型(layer): 像是图像软件PhotoShop中非常流行的图层编辑功能一样<ol>
<li>绝对定位: <code>position: absolute</code> 这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。</li>
<li>相对定位: <code>position: relative</code> 它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，<strong>偏移前的位置保留不动（其他元素依照偏移前的元素位置往后进行排列）</strong>。</li>
<li>固定定位: <code>position: fixed</code> 表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，<strong>它不会随浏览器窗口的滚动条滚动而变化</strong>，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响。</li>
</ol>
</li>
</ul>
</li>
<li>掌握<code>float</code>的相关知识: 浮动模型，让块状元素并排显示</li>
<li>掌握基本的布局方式<ul>
<li>块级元素居中显示: <code>margin: 0 auto</code> 如果想要设置距离顶端的边距的话，可以设置为<code>margin: 80px auto auto</code>，这里必须要写成<code>top|(left and right)|bottom</code>的形式才可以。这里还有一个问题，就是当浏览器宽度缩小时，会形式左右的滚动条，而文字本身不会自适应。**解决方法: 将<code>width: 600px</code>替换为<code>max-width: 600px</code>，尤其是移动设备上的显示尤其重要。</li>
<li>盒子模型的宽度: <code>box-sizing: border-box</code>会使得边框和内边距不再增加整个盒子的宽度，这能让我们更好的控制盒子的大小。</li>
<li>position: <a href="http://zh.learnlayout.com/position.html" target="_blank" rel="external">太多了，详见这里！</a></li>
<li><code>inline-block</code>与<code>float</code>: 它们都可以用来创建多个网格铺满浏览器，不过<code>float</code>的方式更加困难一点，需要在后面清楚浮动才可以。</li>
</ul>
</li>
<li>了解<code>Grid</code>、<code>Flexbox</code>等布局方式: 新的<code>flexbox</code>布局模式被用来重新定义CSS中的布局方式。很遗憾的是最近规范变动过多，导致各个浏览器对它的实现也有所不同。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://louismelo.github.io/2017/10/19/React文档翻译-QuickStart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis Melo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis - 东篱之下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/React文档翻译-QuickStart/" itemprop="url">React文档翻译 - QuickStart</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T11:30:03+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React-文档翻译"><a href="#React-文档翻译" class="headerlink" title="React 文档翻译"></a>React 文档翻译</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>React非常的灵活，你可以在许多项目中都使用它。你可以利用它创建新的app，你也可以逐渐地将它引入一个已有的代码库，而不用进行重写。</p>
<p>以下是一些我们开始的途径:</p>
<ul>
<li>尝试React</li>
<li>创建一个新的App</li>
<li>将React加入现有的App</li>
</ul>
<h3 id="尝试React"><a href="#尝试React" class="headerlink" title="尝试React"></a>尝试React</h3><p>如果你只是想随便玩玩React，那么你可以使用<a href="https://codepen.io/" target="_blank" rel="external">CodePen</a>，你可以尝试以这个简单的<a href="http://codepen.io/gaearon/pen/rrpgNB?editors=0010" target="_blank" rel="external">Hello World</a>小程序作为开始。你不需要安装任何东西，直接试着修改它，看看运行结果就行了。</p>
<hr>
<h3 id="创建一个新的App"><a href="#创建一个新的App" class="headerlink" title="创建一个新的App"></a>创建一个新的App</h3><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>是创建一个新的React单页应用的最好的方式。它可以帮你搭建你的开发环境，这样你就可以使用那些最新的Javascript特性了。它提供了非常棒的开发体验，并且会优化你的最终生产版本。<br>PS: 你需要安装<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>，并且版本&gt;=6。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line">create-react-app my-app</div><div class="line"></div><div class="line"><span class="built_in">cd</span> my-app</div><div class="line">npm start</div></pre></td></tr></table></figure>
<p>Create React App并不处理后端逻辑或者数据库，它仅仅创建了一个前端的构建pipeline，所以你可以结合任何的后端技术来使用它。它在底层使用了<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>以及<a href="https://webpack.js.org/" target="_blank" rel="external">Webpack</a>这样的构建工具，但是并不需要你做任何额外的配置。</p>
<p>当你准备好将App部署到生产环境时，你可以运行<code>npm run build</code>来在<code>build</code>文件夹中创建一个优化过的版本。你可以通过以下链接学习更多关于Create React App的知识:</p>
<ol>
<li><a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="external">用户指南</a></li>
</ol>
<hr>
<h3 id="将React加入现有的App"><a href="#将React加入现有的App" class="headerlink" title="将React加入现有的App"></a>将React加入现有的App</h3><p>要开始使用React，你不必重写你的应用程序。</p>
<p>我们建议将React加入到你的应用的某个小部分中去，例如一个独立的小控件，这样你可以知道它是否能很好的配合你的应用。</p>
<p>虽然React可以脱离build pipeline而使用，但是我们强烈推荐你能搭建这样一个环境，这会使你变得更加高效。如今典型的build pipeline包含了以下的几个部分:</p>
<ul>
<li>包管理器(package manager): 例如<a href="https://yarnpkg.com/" target="_blank" rel="external">Yarn</a>或者<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>，它使得你可以使用大量同生态圈的第三方的包，并且可以轻松地对它们进行安装或升级。</li>
<li>模块打包器(bundler): 例如<a href="https://webpack.js.org/" target="_blank" rel="external">webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>，它使你可以写出模块化的代码，并且将它们整合到一个个小的包中去，来优化载入时间。</li>
<li>编译器(compiler): 例如<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>，它使得你写的最新的Javascript也能运行在旧的浏览器上。</li>
</ul>
<h4 id="安装Rea"><a href="#安装Rea" class="headerlink" title="安装Rea"></a>安装Rea</h4><p>我们推荐使用Yarn或者npm来管理前端的依赖。如果你刚刚接触包管理器，那么<a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="external">Yarn的文档</a>将会是一个比较好的学习材料。</p>
<p>要使用Yarn安装React，执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yarn init</div><div class="line">yarn add react react-dom</div></pre></td></tr></table></figure>
<p>要使用npm安装React，执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm init</div><div class="line">npm install --save react react-dom</div></pre></td></tr></table></figure>
<p>PS: Yarn和npm都是从npm的网站那里下载包的。</p>
<h4 id="激活ES6以及JSX"><a href="#激活ES6以及JSX" class="headerlink" title="激活ES6以及JSX"></a>激活ES6以及JSX</h4><p>我们推荐结合Babel使用React，这使得你可以在Javascript代码中使用ES6以及JSX。ES6是一套新的Javascript标准，它使得开发更加简洁。JSX是Javascript一个扩展，它可以与React配合的非常完美。</p>
<p><a href="https://babeljs.io/docs/setup/" target="_blank" rel="external">Babel安装说明</a>解释了如何在不同的构建环境中配置Babel，你需要确保你安装了<a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="external">babel-preset-react</a>以及<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">babel-preset-env</a>，并且在你的<a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="external">.babelrc配置文件</a>中激活了它们，这样你就可以继续了。</p>
<h4 id="使用ES6和JSX的Hello-World"><a href="#使用ES6和JSX的Hello-World" class="headerlink" title="使用ES6和JSX的Hello World"></a>使用ES6和JSX的Hello World</h4><p>我们推荐你使用webpack或者Browserify，这样你可以写出模块化的代码，并且将它们整合到一个个小的包中去，来优化载入时间。</p>
<p>最简单的React例子就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line">ReactDom.render(</div><div class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这段代码渲染了一个id为<code>root</code>的DOM元素，所以你需要在你的HTML文件某处添加这样的一行代码: <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>。</p>
<p>相似地，你也可以使用React渲染你使用其他Javascript UI库写的现有App中的DOM元素。</p>
<h4 id="开发版本与生产版本"><a href="#开发版本与生产版本" class="headerlink" title="开发版本与生产版本"></a>开发版本与生产版本</h4><p>默认情况下，React包含了许多有用的警告。这些警告在开发过程中十分有用。</p>
<p>但是，它们使得React的开发版本(development version)过大也过慢，所以在部署时，你需要使用生产版本(production version)。</p>
<p>了解如何辨别你的网站正使用正确版本的React，并且通过以下途径有效地配置生产build过程:</p>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="external">使用Create React App</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="external">使用Single-File Builds</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="external">使用Brunch</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="external">使用Browserify</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="external">使用Rollup</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="external">使用webpack</a></li>
</ul>
<h4 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h4><p>如果你不想要使用npm来管理客户端的包，<code>react</code>和<code>react-dom</code>也提供了CDN的版本:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的版本是用来为开发服务的，并不适合生产版本，简化并优化过的版本可以通过以下链接获得:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果需要加载特定版本的<code>react</code>和<code>react-dom</code>，可以用版本号替换掉链接中的<code>16</code>。</p>
<p>如果你是使用Bower的，那么React可以通过<code>react</code>包获得。</p>
<h4 id="为什么需要crossorigin属性？"><a href="#为什么需要crossorigin属性？" class="headerlink" title="为什么需要crossorigin属性？"></a>为什么需要crossorigin属性？</h4><p>如果你通过CDN来使用React，那么我们推荐你将crossorigin属性按照如下设置:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们也推荐你检验你所使用的CDN设置了<code>Access-Control-Allow-Origin: *</code>的HTTP header:<br><img src="https://reactjs.org/static/89baed0a6540f29e954065ce04661048-5447f.png" alt=""></p>
<p>这使得你在使用React 16或以后的版本的时候会有一个更好的错误处理的体验。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>开始学习React的最简单的方法就是使用我们在CodePen上给出的这个<a href="http://codepen.io/gaearon/pen/ZpvBNJ?editors=0010" target="_blank" rel="external">Hello World Example</a>。你不需要安装任何东西，你只要在另一个标签页中打开它，并且跟着我们一起研究这个例子就可以了。如果你还是想使用一个本地的开发环境，请查看上一章的具体内容。</p>
<p>最简单的React example就像下面这样👇:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDom.render(</div><div class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这段代码渲染了一个内容为“Hello, world!”的标题。</p>
<p>接下来的几个部分将逐渐地引导你开始使用React。我们将会深入研究React应用的基础构建单元: 元素(elements)和组件(components)。一旦你掌握了它们，你就可以使用这些可复用的小“砖瓦”来构建复杂的应用程序了。</p>
<hr>
<h3 id="关于Javascript的小提示"><a href="#关于Javascript的小提示" class="headerlink" title="关于Javascript的小提示"></a>关于Javascript的小提示</h3><p>React是一个Javascript库，所以这假设你对Javascript语言有一个基本的理解。如果你感觉自己并不是那么自信，那么你可以参考这个教程，这样你就可以更轻松地跟上我们的节奏了。</p>
<p>我们也将在例子中使用一些ES6语句，我们会试着用保守一点的方式去使用它，因为它相对来说还是比较新的，但是我们鼓励你熟悉一下这些知识: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="external">模板字符串</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">let</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="external">const</a>。</p>
<h2 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h2><p>观察下面的变量声明方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>这个有趣的标签既不是字符串也不是HTML。</p>
<p>这样的语句叫做JSX，是Javascript的一个句法扩展。我们推荐结合React使用它来描述UI应该呈现的样子。JSX也许会让你联想到一个模板语言，不过它是拥有完整的Javascript功能的。</p>
<p>JSX产生了React “elements”，我们将会在下一节探索它们是如何被渲染为DOM的。下面的内容，可以让你学到JSX的基础知识，让你快速起步。</p>
<h3 id="在JSX中嵌入表达式"><a href="#在JSX中嵌入表达式" class="headerlink" title="在JSX中嵌入表达式"></a>在JSX中嵌入表达式</h3><p>你可以通过将代码包裹在花括号内，在JSX中嵌入任何的Javascript表达式。</p>
<p>比方说，<code>2+2</code>，<code>user.firstName</code>，或者<code>formatName(user)</code>都是有效的表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> user = &#123;</div><div class="line">  firstName: <span class="string">'Louis'</span>,</div><div class="line">  lastName: <span class="string">'Melo'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  &lt;h1&gt;</div><div class="line">    Hello, &#123;formatName(user)&#125;!</div><div class="line">  &lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">ReactDOM.render(</span></div><div class="line"><span class="regexp">  element,</span></div><div class="line"><span class="regexp">  document.getElementById('root')</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure>
<p>我们将JSX分成了好几行来提高了它的可阅读性。虽然这不是必要的，但是当这样做的时候，我们也推荐你使用括号将它包裹住，防止 <strong>自动补全分号</strong> 的陷阱。</p>
<h3 id="JSX也是一个表达式"><a href="#JSX也是一个表达式" class="headerlink" title="JSX也是一个表达式"></a>JSX也是一个表达式</h3><p>在编译过后，JSX表达式会变成正常的Javascript对象。</p>
<p>这意味着，你可以在<code>if</code>语句以及<code>for</code>循环中使用JSX，并可以将它赋值给变量，将它作为参数接收，也可以通过方法返回它:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (user) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用JSX声明属性"><a href="#使用JSX声明属性" class="headerlink" title="使用JSX声明属性"></a>使用JSX声明属性</h2><p>你可以使用引号来将字符文字声明为属性:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>你也可以使用花括号来嵌入Javascript表达式作为属性:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>在使用Javascript表达式和花括号作为属性的时候，不要再添加引号。你应该使用这二者的其一，而不是同时使用它们两个。</p>
<h3 id="使用JSX声明子节点-children"><a href="#使用JSX声明子节点-children" class="headerlink" title="使用JSX声明子节点(children)"></a>使用JSX声明子节点(children)</h3><p>如果一个标签是空标签，你可以直接以<code>/&gt;</code>作为结尾:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></div></pre></td></tr></table></figure>
<p>JSX标签也有可能包含子节点:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="JSX防止注入攻击"><a href="#JSX防止注入攻击" class="headerlink" title="JSX防止注入攻击"></a>JSX防止注入攻击</h3><p>将用户输入嵌入在JSX是非常安全的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</div><div class="line"><span class="comment">// This is safe:</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>默认情况下，React DOM在渲染之前就会（？？？）任何嵌套在JSX中的值，因此它保证了你永远不能注入任何没有在你的应用中显示声明的代码。一切都会在渲染之前被转换成字符串，这也有效阻止了<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XSS攻击(cross-site-scripting)</a>。</p>
<h3 id="JSX意味着对象"><a href="#JSX意味着对象" class="headerlink" title="JSX意味着对象"></a>JSX意味着对象</h3><p>Babel将JSX编译为对<code>React.createElement()</code>方法的调用。</p>
<p>下面的这两个例子是完全一致的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</div><div class="line">    Hello, world!</div><div class="line">  &lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = React.createElement(</div><div class="line">  <span class="string">'h1'</span>,</div><div class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</div><div class="line">  <span class="string">'Hello, world!'</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>React.createElement()</code>帮助你执行了一些bug检查，但是更重要的是，它创建了如下的一个对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：这个结构已被简化</span></div><div class="line"><span class="keyword">const</span> element = &#123;</div><div class="line">  type: <span class="string">'h1'</span>,</div><div class="line">  props: &#123;</div><div class="line">    className: <span class="string">'greeting'</span>,</div><div class="line">    children: <span class="string">'Hello, world!'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样的对象被称为“React elements”。你可以将它们认作是对于你想要在屏幕上看到的东西的描述。React会读取这些对象，然后用它们来构建DOM，并且保持它们的状态更新。</p>
<p>我们将在下一节研究如何将React elements渲染到DOM。</p>
<blockquote>
<p><strong>Tip:</strong><br>在Atom编辑器中，可以搜索language-babel来使得编辑器支持对于ES6和JSX的高亮显示。</p>
</blockquote>
<h2 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h2><p>元素是React Apps的最小构建单元。</p>
<p>一个元素描述了你想要在屏幕上看到的东西:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>与浏览器DOM元素不同的是，React elements就是普通的对象，其创建也十分简单。React DOM关心的是更新DOM以匹配React elements。</p>
<p>请注意: 这里有可能会造成与“components”概念的混淆，我们将在下一节介绍components，elements其实是构成components的东西。</p>
<hr>
<h3 id="将元素渲染进DOM中"><a href="#将元素渲染进DOM中" class="headerlink" title="将元素渲染进DOM中"></a>将元素渲染进DOM中</h3><p>假定有一个<code>&lt;div&gt;</code>在你的HTML文件的某处吧:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们将这个称为一个“root” DOM节点，因为它其中的所有东西都将由React DOM管理。</p>
<p>只用React构建的应用通常只有一个单一的根DOM节点。如果你是将React整合进一个已有的app，那么你可以有任意多个隔离的根DOM节点。</p>
<p>要渲染一个React element为一个根DOM节点，需要将两者都传递给<code>ReactDOM.render()</code>方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<h3 id="更新被渲染的元素"><a href="#更新被渲染的元素" class="headerlink" title="更新被渲染的元素"></a>更新被渲染的元素</h3><p>React elements是无法修改的(immutable)。一旦你创建了一个元素，你就不能改变它的子节点或是属性。一个元素就像一部电影里的单独一帧: 它代表了某个特定时间点的用户界面。</p>
<p>根据我们到目前为止学到的知识，更新用户界面的唯一方法是: 创建一个新的元素并将它传递给<code>ReactDOM.render()</code>方法。</p>
<p>思考下面这个时钟的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  );</div><div class="line">  ReactDOM.render(</div><div class="line">    element,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>每隔一秒钟，<code>setInterval()</code>的回调方法就会调用一次<code>ReactDOM.render()</code>方法。</p>
<p>注意，在实践中，大多数的React apps都只调用一次<code>ReactDOM.render()</code>方法，在下一节我们将会学习这些代码是如何被封装(encapsulated)到有状态的components中去的。</p>
<hr>
<h3 id="React只会进行有必要的更新"><a href="#React只会进行有必要的更新" class="headerlink" title="React只会进行有必要的更新"></a>React只会进行有必要的更新</h3><p>React DOM会将元素及其子节点与之前的相比较，并且只会对DOM进行有必要的更新，将DOM变到所需要的状态。</p>
<p>这一点，你可以从上一个例子中看出来，利用浏览器工具，尽管我们每隔一秒都创建一个描述整个UI树的元素，但是只有内容因更新DOM而发生改变的文本节点发生了变化。</p>
<p>根据我们的经验，相比于思考如何随着时间改变UI，思考在给定时刻UI所要呈现的样子会消除非常多的bug。</p>
<h2 id="Components-and-Props"><a href="#Components-and-Props" class="headerlink" title="Components and Props"></a>Components and Props</h2><p>Components使你能够将UI分成独立且可重复利用的小块，并且独立地思考每一小块UI。</p>
<p>从概念上讲，components就像是JavaScript中的方法，它们能够接受任意的输入（这里被称为props），并且返回描述了在屏幕上呈现何物的React elements。</p>
<hr>
<h3 id="Functional-and-Class-Components"><a href="#Functional-and-Class-Components" class="headerlink" title="Functional and Class Components"></a>Functional and Class Components</h3><p>定义一个component的最简单的方法就是编写一个Javascript方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>)</span>&#123;</div><div class="line">  retrun &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class="regexp">/h1&gt;;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>这个方法就是一个有效的React component，因为它接受了一个单独的props，并且返回了一个React element，我们将这种组件叫做方法性组件（functional components），因为它在字面上就是一个JavaScript方法。</p>
<p>你也可以使用一个<code>ES6 Class</code>来顶一个component:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从React的视角来看，以上的两个components是同等的。</p>
<p>Classes具有一些额外的特性，我们将在下一章进行讨论。在那之前，我们将使用functional components，因为它比较简单明了。</p>
<hr>
<h3 id="Rendering-a-component"><a href="#Rendering-a-component" class="headerlink" title="Rendering a component"></a>Rendering a component</h3><p>之前，我们只碰到过表示DOM标签的React elements:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></div></pre></td></tr></table></figure>
<p>然而，elements也可以表示用户定义的components:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Snow"</span> /&gt;</span>;</span></div></pre></td></tr></table></figure>
<p>当React见到一个表示用户定义的componet的element时，它就将JSX的属性以一个单独的对象传递给这个component，我们将这个对象叫做props。</p>
<p>举个例子，这段代码将会打印 Hello, snow:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"snow"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">ReactDOM.render(</span></div><div class="line"><span class="xml">  element,</span></div><div class="line"><span class="xml">  document.getElementById('root')</span></div><div class="line"><span class="xml">);</span></div></pre></td></tr></table></figure>
<p>让我们重新看一下这个例子中发生了什么:</p>
<ol>
<li>我们使用 <code>&lt;Welcome name=&quot;snow&quot; /&gt;</code> 这个元素，调用了 <code>ReactDOM.render()</code> 方法</li>
<li>React以 <code>{name: &#39;snow&#39;}</code> 作为props，调用了 <code>Welcome</code> 组件</li>
<li>我们的 <code>Welcome</code> 组件返回了 <code>&lt;h1&gt;Hello, snow&lt;/h1&gt;</code> 元素作为结果</li>
<li>ReactDOM快速地更新了DOM</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.png"
              alt="Louis Melo" />
          
            <p class="site-author-name" itemprop="name">Louis Melo</p>
            <p class="site-description motion-element" itemprop="description">平凡的人生千篇一律，而不凡的人生万里挑一。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Louis Melo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

  <!-- <script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script> -->
</body>
</html>
